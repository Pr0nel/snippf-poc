# docker-compose.yml
# =============================================
# Archivo de orquestación para el proyecto SNIPPF
# Levanta dos servicios:
#   1. db      → PostgreSQL 16
#   2. web     → API FastAPI
# =============================================

# 1) Versión de sintaxis (3.9 = funciones modernas y soporte long-term)
version: "3.9"

# 2) Bloque reutilizable de variables de entorno
#    - ${VAR:-default}  → usa VAR si existe, sino el valor por defecto
#    - ${VAR:?err}      → aborta si falta la variable (útil para passwords)
x-common-variables: &common-vars
  POSTGRES_USER: ${POSTGRES_USER:-postgres}
  POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:?err}
  POSTGRES_DB: ${POSTGRES_DB:-snippfdb}

# 3) Definición de servicios
services:
  # -----------------------------------------
  # SERVICIO: PostgreSQL
  # -----------------------------------------
  db:
    # Imagen oficial, ligera y con soporte para arquitecturas ARM/AMD
    image: postgres:16-alpine
    # Renombrar el contenedor para facilitar identificación
    container_name: snippf_postgres
    # Reiniciar siempre que Docker se reinicie (excepto si se para manualmente)
    restart: unless-stopped
    # Hereda las variables del bloque reutilizable (ver punto 2)
    environment: *common-vars
    # Mapeo puerto HOST:CONTAINER. 5432 por defecto o el que definas en .env
    ports:
      - "${DB_PORT:-5432}:5432"
    # Persistencia de datos fuera del contenedor
    volumes:
      - pg_data:/var/lib/postgresql/data
    # Healthcheck: espera a que PostgreSQL esté listo antes de arrancar dependientes
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres}"]
      interval: 15s # cada cuánto se intenta
      timeout: 5s # cuánto espera cada intento
      retries: 10 # cuántos fallos tolera antes de marcar como "unhealthy"

    # Logs rotativos para no llenar el disco
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # -----------------------------------------
  # SERVICIO: API FastAPI
  # -----------------------------------------
  web:
    # Construye la imagen a partir del Dockerfile en la raíz
    build: .
    # Nombre fácil de recordar
    container_name: snippf_api
    restart: unless-stopped
    # Archivo extra para variables adicionales (por ejemplo, SECRET_KEY, DEBUG, etc.)
    env_file: .env
    # Puerto de host mapeado; 8000 por defecto o el que definas en .env
    ports:
      - "${WEB_PORT:-8000}:8000"
    # No arranca hasta que PostgreSQL esté "healthy"
    depends_on:
      db:
        condition: service_healthy
    # Límites de recursos para evitar que consuma toda la CPU/RAM
    deploy:
      resources:
        limits:
          cpus: "1.0"
          memory: 512M
    # Logs rotativos
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

# 4) Volumen nombrado para persistir datos de PostgreSQL
volumes:
  pg_data:

# 5) Red personalizada para que los servicios se comuniquen internamente
networks:
  default:
    name: snippf_net # nombre legible
